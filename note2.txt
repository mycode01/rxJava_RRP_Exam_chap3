멀티코어 환경에서의 논리프로세서 마다 작업을 배치해 동시실행 가능.
rxjava에서는 비동기 처리를 수행할수있도록 api제공

기본적으로 한 스레드에서 연산자와 소비자의 작업처리가 이루어짐.
1스레드에서는 작업이 끝나야 다음작업이 실행되기때문에 각각의 처리를 한 스레드에서 작업한다면 
각각의 작업 속도에 따라 서로 영향을 받음.
즉 데이터를 통지하는측은 뿌려주기만, 데이터를 소비하는 쪽은 받아서 처리하기만 하지만
1스레드에서는 소비를 기다렸다가 뿌려줘야하기때문에 영향을 받음.

원래대로라면
인터벌 시간인 1초 + 소비시간인 0.5초 = 한 사이클에 걸리는 시간 1.5초가 되어야 하겠지만,
api자체적으로 "기능을 제공" 한다고 하고있지만?

flowable, observable 을 생성하는 메서드에 따라 수행될 스레드가 달라지기도 함.
just, from 같은 이미 확정된 데이터 통지는 메인스레드(아마 실행되는 스레드? literal하게 main)
timer나 interval 같은 시간과 관련된 처리는 별도의 스레드(Exam3_6, 3_7)

rxjava에서는 통지하는 측과 처리하는 측의 작업이 논리적으로 분리되어있음.
통지는 통지만, 처리는 처리만.
하여 서로의 작업이 어떻게 이루어졌는지 신경쓰지 않아도 되며, 각각의 스레드로 분리해도 안전함.
이렇게 서로 각 스레드를 분리하여 비동기처리할때 처리작업을 실행하는 스레드 종류를 설정할수있는
subscribeOn 메서드, 받는 측의 스레드 종류를 설정할수있도록 observeOn메서드를 제공함.
스레드 종류를 설정할때는 용도에 따라 스레드를 관리하는 스케줄러 지정해야함

rxjava에서는 자바 표준 api를 사용하지 않고 제공하는 스케줄러클래스로 비동기 처리를 할수있음.

scheduler 종류 > 단순히 스레드 풀의 차이 일 뿐 뭔가 특별한걸 해주는것은 아님.
computation : 연산처리. 스레드 풀을 이용하기 때문에 논리프로세서 수 만큼 캐싱, 대기시간 없이 빠르게 처리 해야할때.
io : I/O작업 스케쥴러, 필요에 따라 새로 생성
single : 싱글스레드, 메인과는 별도의 한개의 스레드를 이용
newThread : 매번 새로운 스레드, 매우 오래실행되는 작업
from : 지정한 Executor가 생성한 스레드풀을 이용하여 작업, 스레드 숫자를 제한하기 위해서 사용한다고 함.
trampoline : 현재스레드에 처리작업을 추가, 무한한 크기의 queue를 사용하여 한개씩 처리 하기때문에 순서가 바뀌지 않음.

io, computation은 비슷한 작업을 하지만 용도가 다름.
io는 스레드 풀에서 가져오고, 없다면 새 스레드를 만듬. io작업은 사용자의 환경에 따라 언제 끝날지 모르니까.
computation은 논리 프로세서 수를 넘지 않는 선에서 가져옴.
io스케쥴러는 공유 i/o작업을 하기에는 적절하지 못하며, 처리작업을 thread-safe하게 구현하거나, single을 사용 >
뒤에 설명하지만 i/o용 스레드지만 공유 객체를 안전하게 사용하게 해주는것은 아니다.

스케줄러를 선택하지 않고도 기본 스레드에서 모든 처리작업이 가능함.(시간 처리 작업 예외)

subscribeOn 
생산자(flowable, observable)의 처리작업 스케쥴러 설정
최초 1회 설정만 적용됨. 이후는 무시됨. 3-8
interval같은 시간처리작업은 스케줄러가 자동으로 지정되기때문에 subscribeOn을 사용해도 무시됨.

observeOn
데이터를 받아 처리하는 작업 스케쥴러 설정
observeOn(Scheduler scheduler, Boolean delayError, int BufferSize)
1 스케쥴러
2 에러 통지방식, false - 곧바로 에러통지, true - 데이터 처리 이후 에러 통지
3 버퍼에 담을 대기 데이터 크기
데이터 크기에 따라 배압설정 BackpressureMode.DROP일때 못받고 넘어가는 데이터가 있을수 있음.(Exam3_9)


Flowable/ observable을 생성하는 메서드에 따라서 스레드처리가 다를수 있음.
책에서는 비동기 처리와 관련된 flatmap, concatmap, concatmapeager 만 설명함.

flatMap
변환 연산자로서, 원본 데이터를 통지시 한꺼번에 처리하여 통보함. 자바8 stream flatmap 아님
예를들어 flatmap(d->Flowable.just(d+"x"));로 처리한다면, 
생성된 flowable을 subscribe했을때, 원본데이터+"x"를 통지받을수 있음.
그리고 스케쥴러 설정이 되어 각기 다른 스레드에서 실행되게 됨.
비동기 처리이기때문에 원본데이터의 순서를 보장하지 않음.(Exam3_10)

concatMap
flatMap과 비슷하지만 순차대로 처리하여 순서를 보장함.(비동기)
이전에 통지된 데이터를 아직 처리못했다면 끝날때까지 기다리기 때문에 성능에 많은 영향을 줌.(Exam3_11)

concatMapEager
위 두 메서드의 성격을 합쳐둔듯한 연산자.
flatMap처럼 한꺼번에 처리되지만 concatMap처럼 순서를 보장함.
처리는 한꺼번에 되지만, 순서를 보장하기위해서 내부에 버퍼를 두고 처리
통지전까지 데이터를 쌓아야하기때문에 데이터가 많다면 문제가 될수있음.(Exam3_12)
한 스레드만 사용함?


타 스레드간의 공유객체
생산자와 소비자 간 처리되는 객체라도 외부에서 접근이 가능하다면
순차성에 문제가 생길수 있다. 생산자가 소비자에게 데이터를 넘기며 
생산자와 소비자간의 순차성은 지켜지지만, 어디까지나 둘만의 순차성이고
외부에서 공유되는 객체라면 문제가 발생함. 책에서는 두 소비자의 컨디션레이스를 예를들었음.(Exam3_13)
그리고 rxjava에서는 대책을 제공하는데, merge메서드로 두 생산자를 묶어서 순차성을 지켜줌(Exam3_15)
공유객체처리를 동기화 시켜줘도 처리속도가 늦다면 각 소비자에게 영향이 감


























