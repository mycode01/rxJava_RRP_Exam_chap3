rxjava는 두가지 디자인 패턴에서 영감을 받음.
옵저버패턴, 이터레이터 패턴

옵저버 패턴은 gOf에서 처음 제시한 디자인 패턴중 한가지
'관찰 대상'에게 변경이 발생했을때 해당 객체를 관찰하는 '관찰자'에게 통보하여 상태를 동기화 할수있도록 하는 디자인 패턴.

subject(관찰대상)이 observer(관찰자)를 관리하고,
관찰대상의 상태가 변경돼었을때 관찰자의 update메소드를 호출하여 인자로 자신의 상태값을 넘겨 
관찰자의 콘크리트 클래스에서 관찰대상의 상태를 소비하는 구조

Rxjava의 생산자 <> 소비자 관계에서 적용됨.
다만 rxjava에서는 단순한 관찰대상 상태 변경뿐만 아니라 처리 시작 준비, 모든 처리가 끝났음을 알리는 통지, 처리중에러 발생 통지가 추가되었다.

이터레이터 패턴역시 마찬가지로 GoF에서 제시된 패턴중 한가지
자료 구조와, 접근 방식을 분리하여 관리할수있는 패턴으로, 자료 구조에 구애받지 않고 동일한 인터페이스로 원소를 순회할수 있도록 하는 디자인 패턴.

Iterator 인터페이스를 구현한 클래스를 만들어서 해당 자료구조가 가진 원소를 순회할수있는 기능을 정의 해야하고,
집합체 안에서 Iterator를 만드는 메소드를 제공해야함.

rxjava에서는 생산자 = aggregate이므로 데이터를 공급하는 역할도 해야함.
하지만 이터레이터 패턴에서는 소비자가 필요에 의해서 next()를 부르지만, rxjava에서는 공급자가 소비자에게 통지하는 형태.


pull방식으로 처리할수 없는 데이터를 처리할수있다?
데이터가 모두 모여 컬렉션따위로 만들어 진 이후에 처리를 시작할수있다. hasNext를 불렀을때 false가 떨어지며 작업이 끝나버림.
하지만 RXJAVA에서는 데이터가 다 만들어지지 않은 상태에서도 처리를 시작할수있다. onComplete(혹은 onError)으로 끝났는지 안끝났는지를 판별하기 때문.
hasNext가 없고, 데이터가 만들어졌을때 통보가 되므로.
이터레이터 패턴 = 생성이 완료 된 이터레이터를 대상으로 처리만 가능
rxjava = hasNext없이 통지가 되므로 onComplete이나 onError가 발생할때까지 무한정으로 처리 가능


